import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { courseServiceAPI } from 'EduSmart/api/api-course-service';
import type { CreateCourseState } from '../CreateCourse/CreateCourseStore';
/* eslint-disable */
// @ts-nocheckt { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { courseServiceAPI } from 'EduSmart/api/api-course-service';
import type { CreateCourseState } from '../CreateCourse/CreateCourseStore';
/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars */

export interface UpdateCourseState {
    // Loading states
    isUpdating: boolean;
    error: string | null;
    
    // Actions
    updateCourse: (courseData: CreateCourseState) => Promise<boolean>;
    updateCourseWithModules: (courseData: CreateCourseState) => Promise<boolean>;
    reset: () => void;
}

const initialState = {
    isUpdating: false,
    error: null,
};

// Helper function to get subject code
const getSubjectCode = (subjectId: string): string => {
    const subjectCodeMap: Record<string, string> = {
        'a4917fc0-bbcc-46b1-a7c8-f32e1d2aa298': 'PRF192',
        'a83eabde-fb96-4732-88f3-3e7a846796bc': 'MAE101',
        '432cabc2-79bd-42ac-a67b-fc233dd3a6bc': 'CEA201',
        '3ed33ae3-da55-49f7-b563-41ca0503fab5': 'SSL101C',
        '63368d18-6112-413d-9815-4e31597b6e4c': 'CSI104',
        '5e8967c9-2971-4250-a7fc-a8a26ca7f106': 'NWC203C',
        '0611fe1b-416d-49eb-b0bd-b0ff73cc00c9': 'SSG104',
        'e70ee6db-2fc9-4176-adae-904973bcc475': 'PRO192',
        'ec341342-0993-42b2-a4df-ff0433381605': 'MAD101',
        'b47af2e8-ac4c-4328-b61a-7ba0446556a7': 'OSG202',
        'ed305e62-8cdc-49af-b7d0-290c54a6dbfb': 'CSD201',
        '16299387-cb9f-476c-aff1-a93fcd3d9266': 'DBI202',
        '75ef24fc-2915-4a76-9c26-b4ff1af07f2e': 'LAB211',
        '8d6297cd-98df-4ed0-9c52-cce0be2642da': 'JPD113',
        'c1604ae9-5ee3-457d-b7d0-186546f490ba': 'WED201C',
        'c61bfce2-fc50-478f-a33d-cd2031211125': 'SWE201C',
        '006449aa-5a7e-4d91-990a-5ffefaa6d220': 'JPD123',
        'bc1cedaa-4279-4bca-b5d2-60cd4705b4dc': 'IOT102',
        '4bbc5bf7-bfe9-4762-90cd-7825ca9bffde': 'PRJ301',
        'a7a8d965-8564-4ad9-ac34-2c8c76f7103b': 'MAS291',
        '7d6c6094-fcd2-4521-b568-09c5fb796c75': 'SWR302',
        'de4982a0-82aa-48b0-b824-8267edb15a55': 'SWT301',
        'a4b86226-5d71-4e97-a822-284ab4bca343': 'SWP391',
        '898e94b7-cbab-4b6d-857b-3a3a09dfbe0e': 'ITE302C',
        '2a56f88e-29c4-4482-92c3-23ae0de88d72': 'OJT202',
        '810cc767-1a1f-42ab-8510-d670aa11a69b': 'ENW492C',
        '9b9b36a8-5dbf-4ba3-8caf-3645716918c2': 'EXE101',
        '3ccd8b12-32a5-451d-9cc7-e034c3c544f0': 'PRU212',
        '7b8bbd5b-abdf-4203-800c-1890144a6159': 'PMG201C',
        'fa1f6445-3fc7-4284-b8ac-0338148cd10a': 'SWD392',
        'd3d0a48d-ba44-4c8a-b9b3-d6cf9e6e2166': 'MLN122',
        'a9030ae8-8799-4548-82ab-6df7e5fd0fef': 'MLN111',
        '0773bda7-4280-4dbe-aed2-40bbc6ecf324': 'EXE201',
        '6c8111e7-0bb2-45a4-b0c3-13ebc34bb621': 'WDU203C',
        '9119e3a2-1471-4521-99bc-d28e981c2bfd': 'PRM392',
        'df536a34-ad72-423d-b398-bf8727287d12': 'MLN131',
        '5e0350ac-c664-4818-93f0-8b3b1eb244df': 'VNR202',
        '15f5dda4-68b9-4b97-81d5-800a250e0a4e': 'HCM202',
        '7f0174b9-2a64-480e-9be5-df87092c9f70': 'SEP490',
        '888a4c89-ea86-4653-aea7-9c8d87139928': 'PRN212',
        '2857f69c-c1c7-4d87-a365-79a59af754fb': 'PRN222',
        'b48cb061-4bc6-4eb7-a5b7-856e01d9c283': 'PRN232',
    };
    
    return subjectCodeMap[subjectId] || 'PRF192';
};

// Convert CreateCourseState to complete update DTO format
const convertToCompleteUpdateDto = async (state: CreateCourseState): Promise<any> => {
    // Get lecturer ID from JWT token
    let teacherId = '';
    
    try {
        const { getUserIdFromTokenAction } = await import('EduSmart/app/(auth)/action');
        const userInfo = await getUserIdFromTokenAction();
        
        if (userInfo.ok && userInfo.userId) {
            teacherId = userInfo.userId;
        } else {
            throw new Error('Unable to get lecturer ID from logged-in account');
        }
    } catch (error) {
        throw new Error('Failed to get lecturer ID: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
    
    const dto = {
        teacherId: teacherId,
        subjectId: state.courseInformation.subjectId,
        subjectCode: state.courseInformation.subjectCode || getSubjectCode(state.courseInformation.subjectId),
        title: state.courseInformation.title,
        shortDescription: state.courseInformation.shortDescription,
        description: state.courseInformation.description,
        courseImageUrl: state.courseInformation.courseImageUrl,
        courseIntroVideoUrl: state.courseInformation.courseIntroVideoUrl,
        learnerCount: 0,
        durationMinutes: state.courseInformation.durationMinutes,
        durationHours: Math.round((state.courseInformation.durationMinutes || 0) / 60 * 100) / 100,
        level: state.courseInformation.level,
        price: state.courseInformation.price,
        dealPrice: state.courseInformation.dealPrice,
        isActive: state.courseInformation.isActive,
        
        objectives: state.objectives.map((obj, idx) => ({
            objectiveId: obj.id || `obj-${idx}-${Date.now()}-${Math.random().toString(36).substring(7)}`, // Use existing ID or generate unique one
            content: obj.content,
            positionIndex: idx + 1, // Start from 1
            isActive: obj.isActive,
        })),
        
        requirements: state.requirements.map((req, idx) => ({
            requirementId: req.id || `req-${idx}-${Date.now()}-${Math.random().toString(36).substring(7)}`, // Use existing ID or generate unique one
            content: req.content,
            positionIndex: idx + 1, // Start from 1
            isActive: req.isActive,
        })),
        
        audiences: state.targetAudience.map((aud, idx) => ({
            audienceId: aud.id || `aud-${idx}-${Date.now()}-${Math.random().toString(36).substring(7)}`, // Use existing ID or generate unique one
            content: aud.content,
            positionIndex: idx + 1, // Start from 1
            isActive: aud.isActive,
        })),
        
        courseTags: state.courseTags.map(tag => ({
            tagId: tag.tagId,
        })),
        
        modules: state.modules.map((module, moduleIdx) => ({
            moduleId: module.id,
            moduleName: module.moduleName,
            description: module.description,
            positionIndex: moduleIdx + 1, // Start from 1
            isActive: module.isActive,
            isCore: module.isCore !== undefined ? module.isCore : true,
            durationMinutes: module.durationMinutes || 0,
            durationHours: Math.round((module.durationMinutes || 0) / 60 * 100) / 100,
            level: module.level || 1,
            objectives: module.objectives?.map((obj, idx) => ({
                objectiveId: obj.id,
                content: obj.content,
                positionIndex: idx + 1,
                isActive: obj.isActive
            })) || [],
            moduleDiscussionDetails: module.discussions?.map((disc, idx) => ({
                discussionId: disc.id,
                discussionTitle: disc.title,
                discussionContent: disc.description || '',
                positionIndex: idx + 1,
                isActive: disc.isActive
            })) || [],
            moduleMaterialDetails: module.materials?.map((mat, idx) => ({
                materialId: mat.id,
                materialName: mat.title,
                description: mat.description,
                fileUrl: mat.fileUrl,
                positionIndex: idx + 1,
                isActive: mat.isActive
            })) || [],
            lessons: module.lessons.map((lesson, lessonIdx) => ({
                lessonId: lesson.id,
                title: lesson.title,
                videoUrl: lesson.videoUrl,
                videoDurationSec: lesson.videoDurationSec || 0,
                positionIndex: lessonIdx + 1, // Start from 1
                isActive: lesson.isActive,
                lessonQuiz: lesson.lessonQuiz ? {
                    quizSettings: lesson.lessonQuiz.quizSettings ? {
                        durationMinutes: lesson.lessonQuiz.quizSettings.durationMinutes,
                        passingScorePercentage: lesson.lessonQuiz.quizSettings.passingScorePercentage,
                        shuffleQuestions: lesson.lessonQuiz.quizSettings.shuffleQuestions,
                        showResultsImmediately: lesson.lessonQuiz.quizSettings.showResultsImmediately,
                        allowRetake: lesson.lessonQuiz.quizSettings.allowRetake,
                    } : undefined,
                    questions: lesson.lessonQuiz.questions?.map(q => ({
                        questionType: q.questionType,
                        questionText: q.questionText,
                        explanation: q.explanation,
                        options: q.options?.map(opt => ({
                            text: opt.text,
                            isCorrect: opt.isCorrect,
                        })),
                    })),
                } : null
            })),
            moduleQuiz: module.moduleQuiz ? {
                quizSettings: module.moduleQuiz.quizSettings ? {
                    durationMinutes: module.moduleQuiz.quizSettings.durationMinutes,
                    passingScorePercentage: module.moduleQuiz.quizSettings.passingScorePercentage,
                    shuffleQuestions: module.moduleQuiz.quizSettings.shuffleQuestions,
                    showResultsImmediately: module.moduleQuiz.quizSettings.showResultsImmediately,
                    allowRetake: module.moduleQuiz.quizSettings.allowRetake,
                } : undefined,
                questions: module.moduleQuiz.questions?.map(q => ({
                    questionType: q.questionType,
                    questionText: q.questionText,
                    explanation: q.explanation,
                    options: q.options?.map(opt => ({
                        text: opt.text,
                        isCorrect: opt.isCorrect,
                    })),
                })),
            } : null
        })),
        
        comments: [],
        ratings: [],
        ratingsCount: 0,
        ratingsAverage: 5
    };    
    return dto;
};

// Convert CreateCourseState to basic update DTO format (without modules)
const convertToBasicUpdateDto = async (state: CreateCourseState): Promise<any> => {    
    // Get lecturer ID from JWT token
    let teacherId = '';
    
    try {
        const { getUserIdFromTokenAction } = await import('EduSmart/app/(auth)/action');
        const userInfo = await getUserIdFromTokenAction();
        
        if (userInfo.ok && userInfo.userId) {
            teacherId = userInfo.userId;
        } else {
            throw new Error('Unable to get lecturer ID from logged-in account');
        }
    } catch (error) {
        throw new Error('Failed to get lecturer ID: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
    
    return {
        teacherId: teacherId,
        subjectId: state.courseInformation.subjectId,
        title: state.courseInformation.title,
        shortDescription: state.courseInformation.shortDescription,
        description: state.courseInformation.description,
        courseImageUrl: state.courseInformation.courseImageUrl,
        courseIntroVideoUrl: state.courseInformation.courseIntroVideoUrl,
        durationMinutes: state.courseInformation.durationMinutes,
        level: state.courseInformation.level,
        price: state.courseInformation.price,
        dealPrice: state.courseInformation.dealPrice,
        isActive: state.courseInformation.isActive,
        objectives: state.objectives.map((obj, idx) => ({
            ...(obj.id && { objectiveId: obj.id }),
            content: obj.content,
            positionIndex: idx + 1,
            isActive: obj.isActive,
        })),
        requirements: state.requirements.map((req, idx) => ({
            ...(req.id && { requirementId: req.id }),
            content: req.content,
            positionIndex: idx + 1,
            isActive: req.isActive,
        })),
        audiences: state.targetAudience.map((aud, idx) => ({
            ...(aud.id && { audienceId: aud.id }),
            content: aud.content,
            positionIndex: idx + 1,
            isActive: aud.isActive,
        })),
        courseTags: state.courseTags.map(tag => ({
            tagId: tag.tagId,
        })),
    };
};

export const useUpdateCourseStore = create<UpdateCourseState>()(
    persist(
        (set, get) => ({
            ...initialState,
            
            updateCourse: async (courseData: CreateCourseState) => {
                if (!courseData.courseId) {
                    set({ error: 'No course ID available for update' });
                    return false;
                }
                
                set({ isUpdating: true, error: null });                
                try {
                    const updateDto = await convertToBasicUpdateDto(courseData);
                    
                    // Validate required fields
                    if (!updateDto.teacherId) {
                        throw new Error('Teacher ID is required');
                    }
                    if (!updateDto.subjectId) {
                        throw new Error('Subject ID is required');
                    }
                    if (!updateDto.title) {
                        throw new Error('Course title is required');
                    }
                    if (updateDto.price === undefined || updateDto.price === null) {
                        throw new Error('Course price is required');
                    },
                        hasModules: false
                    }););
                    
                    const response = await courseServiceAPI.updateCourse(courseData.courseId, updateDto);
                    
                    if (response.success) {
                        set({ isUpdating: false });                        return true;
                    } else {
                        set({ 
                            error: response.message || 'Failed to update course',
                            isUpdating: false 
                        });
                        return false;
                    }
                } catch (error: any) {
                    set({ 
                        error: `Network error: ${error?.message || 'Unknown error'}`,
                        isUpdating: false 
                    });
                    return false;
                }
            },
            
            updateCourseWithModules: async (courseData: CreateCourseState) => {
                if (!courseData.courseId) {
                    set({ error: 'No course ID available for update' });
                    return false;
                }
                
                set({ isUpdating: true, error: null });                
                try {
                    const updateDto = await convertToCompleteUpdateDto(courseData);
                    
                    // Validate required fields
                    if (!updateDto.teacherId) {
                        throw new Error('Teacher ID is required');
                    }
                    if (!updateDto.subjectId) {
                        throw new Error('Subject ID is required');
                    }
                    if (!updateDto.title) {
                        throw new Error('Course title is required');
                    }
                    if (updateDto.price === undefined || updateDto.price === null) {
                        throw new Error('Course price is required');
                    }
                    
                    // Validate for duplicate IDs (CRITICAL FIX)
                    const objectiveIds = updateDto.objectives?.map((obj: any) => obj.objectiveId) || [];
                    const requirementIds = updateDto.requirements?.map((req: any) => req.requirementId) || [];
                    const audienceIds = updateDto.audiences?.map((aud: any) => aud.audienceId) || [];
                    
                    const hasDuplicateObjectives = new Set(objectiveIds).size !== objectiveIds.length;
                    const hasDuplicateRequirements = new Set(requirementIds).size !== requirementIds.length;
                    const hasDuplicateAudiences = new Set(audienceIds).size !== audienceIds.length;
                    
                    if (hasDuplicateObjectives || hasDuplicateRequirements || hasDuplicateAudiences) {
}` : 'OK',
                            requirements: hasDuplicateRequirements ? `Has duplicates: ${JSON.stringify(requirementIds)}` : 'OK',
                            audiences: hasDuplicateAudiences ? `Has duplicates: ${JSON.stringify(audienceIds)}` : 'OK',
                        });
                        set({ 
                            error: 'Data validation failed: Duplicate IDs found in objectives, requirements, or audiences',
                            isUpdating: false 
                        });
                        return false;
                    },
                        hasModules: true,
                        modulesCount: updateDto.modules?.length || 0
                    });); + '):', updateDto.objectives); + '):', updateDto.requirements); + '):', updateDto.audiences); + '):', updateDto.courseTags); + '):', updateDto.modules);
                    
                    // Log moduleQuiz details
                    updateDto.modules?.forEach((module: any, idx: number) => {
                        if (module.moduleQuiz) {                        }
                    });
                    
                    const response = await courseServiceAPI.updateCourse(courseData.courseId, updateDto); : 'no response');
                    
                    // Handle different response formats
                    let isSuccess = false;
                    let errorMessage = '';
                    
                    if (response) {
                        // Check if it's an ApiResponse format with success field
                        if (typeof response === 'object' && 'success' in response) {
                            isSuccess = response.success === true;
                            errorMessage = response.message || '';
                        } 
                        // If it's a direct response object (HTTP 200 with data), consider it success
                        else if (typeof response === 'object') {
                            isSuccess = true; // HTTP 200 with data means success
                        }
                        // If it's a string response
                        else if (typeof response === 'string') {
                            try {
                                const parsed = JSON.parse(response);
                                isSuccess = true; // Successfully parsed response
                            } catch {
                                isSuccess = true; // Even if not parseable, HTTP 200 means success
                            }
                        }
                    }
                    
                    if (isSuccess) {
                        set({ isUpdating: false });                        return true;
                    } else {
                        set({ 
                            error: errorMessage || 'Failed to update course with modules',
                            isUpdating: false 
                        });
                        return false;
                    }
                } catch (error: any) {
                    set({ 
                        error: `Network error: ${error?.message || 'Unknown error'}`,
                        isUpdating: false 
                    });
                    return false;
                }
            },
            
            reset: () => {
                set(initialState);
            }
        }),
        {
            name: 'update-course-storage',
            partialize: (state) => ({
                // Only persist error state if needed
                error: state.error,
            }),
        }
    )
);